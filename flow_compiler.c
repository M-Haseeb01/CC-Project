#include <stdio.h>
#include <stdlib.h>
#include "ast.h"
#include "llvm_generator.h"
#include "flowscript.tab.h" // Generated by bison
#include <llvm-c/BitWriter.h> // ADDED FOR LLVMWriteBitcodeToFile

extern FILE *yyin;
extern ASTNode *ast_root;
extern int yyparse(void);

int main(int argc, char **argv) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <input_file.flow>\n", argv[0]);
        return 1;
    }

    yyin = fopen(argv[1], "r");
    if (!yyin) {
        perror(argv[1]);
        return 1;
    }

    printf("Starting parsing for %s...\n", argv[1]);
    int parse_result = yyparse();
    fclose(yyin);

    if (parse_result != 0) {
        fprintf(stderr, "Parsing failed.\n");
        if (ast_root) free_ast(ast_root); // Clean up partial AST if any
        return 1;
    }
    printf("Parsing successful.\n");

    if (!ast_root) {
        fprintf(stderr, "AST root is NULL after successful parsing (empty input?).\n");
        // This can be normal for an empty file if your grammar allows an empty program
        // that results in a NULL ast_root or an empty statement list.
        // If ast_root is an empty statement list, it's fine.
    } else {
        printf("\n--- Abstract Syntax Tree ---\n");
        print_ast(ast_root, 0);
        printf("--- End of AST ---\n\n");
    }


    printf("Initializing LLVM...\n");
    llvm_initialize();
    LLVMGeneratorState* gen_state = create_llvm_generator_state();

    printf("Generating LLVM IR...\n");
    if (ast_root) { // Only generate code if there's an AST
        llvm_generate_code(gen_state, ast_root);
    } else {
        // Handle empty input: create an empty main function in LLVM IR
        LLVMTypeRef main_ret_type = LLVMInt32TypeInContext(gen_state->context);
        LLVMTypeRef main_func_type = LLVMFunctionType(main_ret_type, NULL, 0, 0);
        LLVMValueRef main_func = LLVMAddFunction(gen_state->module, "main", main_func_type);
        LLVMBasicBlockRef entry = LLVMAppendBasicBlockInContext(gen_state->context, main_func, "empty_main_entry");
        LLVMPositionBuilderAtEnd(gen_state->builder, entry);
        LLVMBuildRet(gen_state->builder, LLVMConstInt(main_ret_type, 0, 0));
        printf("Empty input: Generated an empty main function.\n");
    }
    
    char output_filename_ll[256];
    snprintf(output_filename_ll, sizeof(output_filename_ll), "%s.ll", argv[1]);
    if (LLVMPrintModuleToFile(gen_state->module, output_filename_ll, NULL)) {
        fprintf(stderr, "Error writing LLVM IR to %s\n", output_filename_ll);
    } else {
        printf("LLVM IR written to %s\n", output_filename_ll);
    }

    char output_filename_bc[256];
    snprintf(output_filename_bc, sizeof(output_filename_bc), "%s.bc", argv[1]);
    if (LLVMWriteBitcodeToFile(gen_state->module, output_filename_bc) != 0) { // CORRECTED
        fprintf(stderr, "Error writing LLVM bitcode to %s\n", output_filename_bc);
    } else {
        printf("LLVM bitcode written to %s\n", output_filename_bc);
    }

    printf("Cleaning up LLVM...\n");
    free_llvm_generator_state(gen_state);
    llvm_shutdown();

    if (ast_root) {
        printf("Freeing AST...\n");
        free_ast(ast_root);
    }

    printf("Compilation finished.\n");

    printf("\nTo compile the .ll file (e.g., to an executable 'a.out'):\n");
    printf("  clang %s -o a.out\n", output_filename_ll);
    printf("Or using lli to execute directly (JIT):\n");
    printf("  lli %s\n", output_filename_ll);

    return 0;
}
